## 事件传递和响应机制

1. 事件的产生
发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中,为什么是队列而不是栈？因为队列的特点是FIFO，即先进先出，先产生的事件先处理才符合常理，所以把事件添加到队列。

UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。

主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。

找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。

2. 事件的传递
触摸事件的传递是从父控件传递到子控件

也就是UIApplication->window->寻找处理事件最合适的view

注 意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件

3. 应用如何找到最合适的控件来处理事件？
1.首先判断主窗口（keyWindow）自己是否能接受触摸事件
2.判断触摸点是否在自己身上
3.子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤）
4.如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。
3.1 寻找最合适的view底层剖析
两个重要的方法：

```
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;
```

3.2 hitTest:withEvent 方法介绍
什么时候调用？

只要事件一传递给一个控件,这个控件就会调用他自己的hitTest：withEvent：方法
作用

寻找并返回最合适的view(能够响应事件的那个最合适的view)
注 意
1.不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用hitTest:withEvent:方法
2.如果hitTest:withEvent:方法中返回nil，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。

3.3 pointInside:withEvent 方法介绍
判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。

UIView不能接收触摸事件的三种情况：

不允许交互：userInteractionEnabled = NO
隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件
透明度：如果设置一个控件的透明度<0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。
4. 事件的响应
4.1 触摸事件处理的整体过程
1 用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件
2 找到最合适的视图控件后，就会调用控件的touches方法来作具体的事件处理touchesBegan…touchesMoved…touchedEnded…
3 这些touches方法的默认做法是将事件顺着响应者链条向上传递（也就是touch方法默认不处理事件，只传递事件），将事件交给上一个响应者进行处理
4.2 响应者链条
在iOS程序中无论是最后面的UIWindow还是最前面的某个按钮，它们的摆放是有前后关系的，一个控件可以放到另一个控件上面或下面，那么用户点击某个控件时是触发上面的控件还是下面的控件呢，这种先后关系构成一个链条就叫响应者链。也可以说，响应者链是由多个响应者对象连接起来的链条。

在iOS中响应者链的关系可以用下图表示：

![图片](https://upload-images.jianshu.io/upload_images/1055199-2a49a16e1e483b5c.png?imageMogr2/auto-orient/strip|imageView2/2/w/603/format/webp)

响应者对象 能处理事件的对象，也就是继承自UIResponder的对象

作用 能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。

如何判断上一个响应者

1 如果当前这个view是控制器的view,那么控制器就是上一个响应者
2 如果当前这个view不是控制器的view,那么父控件就是上一个响应者
响应者链的事件传递过程

1 如果当前view是控制器的view，那么控制器就是上一个响应者，事件就传递给控制器；如果当前view不是控制器的view，那么父视图就是当前view的上一个响应者，事件就传递给它的父视图
2 在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理
3 如果window对象也不处理，则其将事件或消息传递给UIApplication对象
4 如果UIApplication也不能处理该事件或消息，则将其丢弃
5. 总结
事件处理的整个流程总结：

1.触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。
2.UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。
3.主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成)
4.最合适的view会调用自己的touches方法处理事件
5.touches默认做法是把事件顺着响应者链条向上抛。
如何做到一个事件多个对象处理：
因为系统默认做法是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。

```
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ 
    // 1.自己先处理事件...
    NSLog(@"do somthing...");
    // 2.再调用系统的默认做法，再把事件交给上一个响应者处理
    [super touchesBegan:touches withEvent:event]; 
}
```

事件的传递和响应的区别：
事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。



## 简述内存管理基本原则

之前：OC内存管理遵循“谁创建，谁释放，谁引用，谁管理”的机制，当创建或引用一个对象的时候，需要向她发送alloc、copy、retain消息，当释放该对象时需要发送release消息，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制（MRC）。

目前：iOS 5.0之后引用自动管理机制——自动引用计数（ARC），管理机制与手动机制一样，只是不再需要调用retain、release、autorelease；它编译时的特性，当你使用ARC时，在适当位置插入release和autorelease；它引用strong和weak关键字，strong修饰的指针变量指向对象时，当指针指向新值或者指针不复存在，相关联的对象就会自动释放，而weak修饰的指针变量指向对象，当对象的拥有者指向新值或者不存在时weak修饰的指针会自动置为nil。

如果使用alloc、copy(mutableCopy)或者retian一个对象时,你就有义务,向它发送一条release或者autorelease消息。其他方法创建的对象,不需要由你来管理内存。

向一个对象发送一条autorelease消息,这个对象并不会立即销毁, 而是将这个对象放入了自动释放池,待池子释放时,它会向池中每一个对象发送 一条release消息,以此来释放对象.

向一个对象发送release消息,并不意味着这个对象被销毁了,而是当这个对象的引用计数为0时,系统才会调用dealloc方法,释放该对象和对象本身它所拥有的实例。

其他注意事项

如果一个对象有一个_strong类型的指针指向着，找个对象就不会被释放。如果一个指针指向超出了它的作用域，就会被指向nil。如果一个指针被指向nil，那么它原来指向的对象就被释放了。当一个视图控制器被释放时，它内部的全局指针会被指向nil。用法“：不管全局变量还是局部变量用_strong描述就行。

局部变量：出了作用域，指针会被置为nil。

方法内部创建对象，外部使用需要添加_autorelease;

连线的时候，用_weak描述。

代理使用unsafe_unretained就相当于assign；

block中为了避免循环引用问题，使用_weak描述；

声明属性时，不要以new开头。如果非要以new开头命名属性的名字，需要自己定制get方法名，如:

@property(getter=theString) NSString * newString;
如果要使用自动释放池，用@autoreleasepool{}

ARC只能管理Foundation框架的变量，如果程序中把Foundation中的变量强制换成COreFoundation中的变量需要交换管理权；

在非ARC工程中采用ARC去编译某些类：-fobjc-arc。

在ARC下的工程采用非ARC去编译某些类：-fno-fobjc-arc。
